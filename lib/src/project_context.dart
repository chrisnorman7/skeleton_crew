import 'dart:convert';
import 'dart:io';

import 'package:path/path.dart' as path;
import 'package:pubspec_parse/pubspec_parse.dart';
import 'package:ziggurat/ziggurat.dart';

import '../constants.dart';
import '../json/asset_stores/asset_store_reference.dart';
import '../json/asset_stores/pretend_asset_reference.dart';
import '../json/project.dart';
import '../util.dart';
import 'generated_code.dart';

const _jsonEncoder = JsonEncoder.withIndent('  ');

/// A reference to a project.
class ProjectContext {
  /// Create an instance.
  const ProjectContext({
    required this.project,
    required this.file,
    required this.game,
  });

  /// Load a project from the given [file].
  ProjectContext.fromFile({required this.file, required this.game})
      : project = Project.fromJson(
          jsonDecode(file.readAsStringSync()) as Map<String, dynamic>,
        );

  /// The project that has been loaded.
  final Project project;

  /// The file where [project] resides.
  final File file;

  /// The directory where [file] lives.
  Directory get directory => file.parent;

  /// The game to use.
  final Game game;

  /// Save the [project] to its [file].
  void save() {
    final json = project.toJson();
    final data = _jsonEncoder.convert(json);
    file.writeAsStringSync(data);
  }

  /// Delete the given [asset] from the given [assetStoreReference].
  void deleteAssetReferenceReference({
    required final AssetStoreReference assetStoreReference,
    required final PretendAssetReference asset,
  }) {
    assetStoreReference.assets.removeWhere(
      (final element) => element.id == asset.id,
    );
    save();
    switch (asset.assetType) {
      case AssetType.file:
        final file = File(asset.name);
        if (file.existsSync()) {
          file.deleteSync(recursive: true);
        }
        break;
      case AssetType.collection:
        final directory = Directory(asset.name);
        if (directory.existsSync()) {
          directory.deleteSync(recursive: true);
        }
        break;
    }
  }

  /// Get the generated header for use with the [build] method and the methods
  /// it calls.
  String get generatedHeader {
    final now = DateTime.now();
    return '/// Autogenerated on $now.';
  }

  /// Write the project version.
  void writeVersion() {
    final pubspecFile = File(path.join(directory.path, 'pubspec.yaml'));
    if (pubspecFile.existsSync()) {
      final data = pubspecFile.readAsStringSync();
      final pubspec = Pubspec.parse(
        data,
        sourceUrl: Uri.file(pubspecFile.path),
      );
      final version = pubspec.version;
      if (version != null) {
        final stringBuffer = StringBuffer()
          ..writeln('/// The project version.')
          ..write("const projectVersion = '$version';");
        final file = File(
          path.join(
            directory.path,
            project.outputDirectory,
            versionFile,
          ),
        );
        final code = dartFormatter.format(stringBuffer.toString());
        file.writeAsStringSync(code);
      }
    }
  }

  /// Write dialogue levels.
  void writeDialogueLevels() {
    final dialogueLevels = project.dialogueLevels;
    if (dialogueLevels.isEmpty) {
      return;
    }
    final imports = <String>{'package:ziggurat/levels.dart'};
    final stringBuffer = StringBuffer();
    for (final dialogueLevel in dialogueLevels) {
      final code = dialogueLevel.getCode(this);
      imports.addAll(code.imports);
      stringBuffer.writeln(code.code);
    }
    final generatedCode = GeneratedCode(
      code: stringBuffer.toString(),
      imports: imports,
    );
    final codeBuffer = StringBuffer()
      ..writeln(generatedHeader)
      ..writeln('/// Dialogue levels.')
      ..writeln(generatedCode.getImports())
      ..writeln(generatedCode.code);
    setClipboardText(codeBuffer.toString());
    final file = File(
      path.join(
        directory.path,
        project.outputDirectory,
        dialogueLevelsFile,
      ),
    );
    final code = dartFormatter.format(
      codeBuffer.toString(),
      uri: file.path,
    );
    file.writeAsStringSync(code);
  }

  /// Write tile map levels.
  void writeTileMapLevels() {
    final tileMapLevels = project.tileMapLevels;
    if (tileMapLevels.isEmpty) {
      return;
    }
    final imports = <String>{};
    final stringBuffer = StringBuffer();
    for (final level in tileMapLevels) {
      final code = level.getCode(this);
      imports.addAll(code.imports);
      stringBuffer.writeln(code.code);
    }
    final generatedCode =
        GeneratedCode(code: stringBuffer.toString(), imports: imports);
    final codeStringBuffer = StringBuffer()
      ..writeln(generatedHeader)
      ..writeln('/// Tile map levels.')
      ..writeln(generatedCode.getImports())
      ..writeln(generatedCode.code);
    final file = File(
      path.join(
        directory.path,
        project.outputDirectory,
        tileMapLevelsFile,
      ),
    );
    final code = dartFormatter.format(
      codeStringBuffer.toString(),
      uri: file.path,
    );
    file.writeAsStringSync(code);
  }

  /// Write tile maps.
  void writeTileMaps() {
    final tileMaps = project.tileMaps;
    if (tileMaps.isEmpty) {
      return;
    }
    final stringBuffer = StringBuffer();
    final imports = {'package:ziggurat/ziggurat.dart'};
    for (final tileMap in tileMaps) {
      final code = tileMap.getCode(this);
      imports.addAll(code.imports);
      stringBuffer.writeln(code.code);
    }
    final generatedCode = GeneratedCode(
      code: stringBuffer.toString(),
      imports: imports,
    );
    final codeBuffer = StringBuffer()
      ..writeln(generatedHeader)
      ..writeln('/// Tile maps.')
      ..writeln(generatedCode.getImports())
      ..writeln(generatedCode.code);
    final file = File(
      path.join(directory.path, project.outputDirectory, tileMapsFilename),
    );
    final code = dartFormatter.format(
      codeBuffer.toString(),
      uri: file.path,
    );
    file.writeAsString(code);
  }

  /// Write the flags.
  void writeFlags() {
    final tileMapFlags = project.tileMapFlags;
    if (tileMapFlags.isEmpty) {
      return;
    }
    final imports = <String>{};
    final libraryName = path.basenameWithoutExtension(flagsFilename);
    final stringBuffer = StringBuffer()
      ..writeln(generatedHeader)
      ..writeln('/// Tile map flags.')
      ..writeln('library $libraryName;');
    var value = 1;
    for (final flags in tileMapFlags) {
      final code = flags.getCode(value);
      imports.addAll(code.imports);
      stringBuffer.writeln(code.code);
      value *= 2;
    }
    final generatedCode =
        GeneratedCode(code: stringBuffer.toString(), imports: imports);
    final file = File(
      path.join(
        directory.path,
        project.outputDirectory,
        flagsFilename,
      ),
    );
    final sortedImports = generatedCode.getImports();
    final code = dartFormatter.format(
      '$sortedImports\n${generatedCode.code}',
      uri: file.path,
    );
    file.writeAsStringSync(code);
  }

  /// Write the custom game class.
  void writeGame() {
    final className = project.gameClassName;
    final imports = {
      'package:ziggurat/ziggurat.dart',
    };
    final stringBuffer = StringBuffer()
      ..writeln('/// ${project.gameClassComment}')
      ..writeln('abstract class $className extends Game {')
      ..writeln('/// Create an instance.')
      ..writeln(
        '$className({required super.sdl, required super.soundBackend,})',
      )
      ..writeln(': super(')
      ..writeln('title: ${getQuotedString(project.title)},')
      ..writeln('orgName: ${getQuotedString(project.orgName)},')
      ..writeln('appName: ${getQuotedString(project.appName)},')
      ..writeln('triggerMap: const TriggerMap([');
    final commandTriggers = project.commandTriggers;
    if (commandTriggers.isNotEmpty) {
      imports.add(commandTriggersFilename);
      for (final commandTriggerReference in commandTriggers) {
        final comment = commandTriggerReference.comment;
        final variableName = commandTriggerReference.variableName;
        stringBuffer
          ..writeln('/// $comment')
          ..writeln('$variableName,');
      }
    }
    stringBuffer
      ..writeln('],),);')
      ..writeln('}');
    final codeBuffer = StringBuffer();
    final generatedCode = GeneratedCode(
      code: stringBuffer.toString(),
      imports: imports,
    );
    codeBuffer
      ..writeln(generatedHeader)
      ..writeln('/// Provides the [$className] class.')
      ..writeln(generatedCode.getImports())
      ..writeln(generatedCode.code);
    final file = File(
      path.join(directory.path, project.outputDirectory, gameFilename),
    );
    final code = dartFormatter.format(
      codeBuffer.toString(),
      uri: file.path,
    );
    file.writeAsStringSync(code);
  }

  /// Write all levels.
  void writeLevels() {
    final levels = project.levels;
    if (levels.isEmpty) {
      return;
    }
    final imports = <String>{};
    final stringBuffer = StringBuffer();
    for (final level in levels) {
      final code = level.getCode(this);
      imports.addAll(code.imports);
      stringBuffer.writeln(code.code);
    }
    final generatedCode = GeneratedCode(
      code: stringBuffer.toString(),
      imports: imports,
    );
    final codeBuffer = StringBuffer()
      ..writeln(generatedHeader)
      ..writeln('/// Levels.')
      ..writeln(generatedCode.getImports())
      ..write(generatedCode.code);
    final file = File(
      path.join(
        directory.path,
        project.outputDirectory,
        levelFilename,
      ),
    );
    final code = dartFormatter.format(
      codeBuffer.toString(),
      uri: file.path,
    );
    file.writeAsStringSync(code);
  }

  /// Write all menus.
  void writeMenus() {
    final menus = project.menus;
    if (menus.isEmpty) {
      return;
    }
    final imports = <String>{};
    final stringBuffer = StringBuffer();
    for (final menu in menus) {
      final code = menu.getCode(this);
      imports.addAll(code.imports);
      stringBuffer.writeln(code.code);
    }
    final generatedCode = GeneratedCode(
      code: stringBuffer.toString(),
      imports: imports,
    );
    final codeBuffer = StringBuffer()
      ..writeln(generatedHeader)
      ..writeln('/// Menus.')
      ..writeln(generatedCode.getImports())
      ..write(generatedCode.code);
    final file = File(
      path.join(
        directory.path,
        project.outputDirectory,
        menuFilename,
      ),
    );
    final code = dartFormatter.format(
      codeBuffer.toString(),
      uri: file.path,
    );
    file.writeAsStringSync(code);
  }

  /// Write the given [assetStoreReference].
  void writeAssetStore(final AssetStoreReference assetStoreReference) {
    final storeCode = assetStoreReference.getCode(this);
    final stringBuffer = StringBuffer()
      ..writeln(generatedHeader)
      ..writeln('/// ${assetStoreReference.comment}')
      ..writeln(storeCode.getImports())
      ..writeln(storeCode.code);
    final file = File(
      path.join(
        directory.path,
        project.outputDirectory,
        assetStoresDirectory,
        assetStoreReference.dartFilename,
      ),
    );
    final code = dartFormatter.format(
      stringBuffer.toString(),
      uri: file.path,
    );
    file.writeAsStringSync(code);
  }

  /// Write asset stores.
  void writeAssetStores() {
    final assetStores = project.assetStores;
    final storesDirectory = Directory(
      path.join(
        directory.path,
        project.outputDirectory,
        assetStoresDirectory,
      ),
    );
    if (!storesDirectory.existsSync() && assetStores.isNotEmpty) {
      storesDirectory.createSync(recursive: true);
    }
    assetStores.forEach(writeAssetStore);
  }

  /// Write command triggers.
  void writeCommandTriggers() {
    final commandTriggers = project.commandTriggers;
    if (commandTriggers.isEmpty) {
      return;
    }
    final imports = <String>{};
    final stringBuffer = StringBuffer();
    for (final reference in commandTriggers) {
      final commandTriggerCode = reference.getCode(this);
      imports.addAll(commandTriggerCode.imports);
      stringBuffer.writeln(commandTriggerCode.code);
    }
    final generatedCode = GeneratedCode(
      code: stringBuffer.toString(),
      imports: imports,
    );
    final file = File(
      path.join(
        directory.path,
        project.outputDirectory,
        commandTriggersFilename,
      ),
    );
    final code = dartFormatter.format(
      '$generatedHeader\n/// Command triggers.\n${generatedCode.getImports()}\n${generatedCode.code}',
      uri: file.path,
    );
    file.writeAsStringSync(code);
  }

  /// Build the dart for [project].
  void build() {
    final directory = Directory(project.outputDirectory);
    if (!directory.existsSync()) {
      directory.createSync(recursive: true);
    }
    writeAssetStores();
    writeCommandTriggers();
    writeMenus();
    writeLevels();
    writeGame();
    writeFlags();
    writeTileMaps();
    writeTileMapLevels();
    writeDialogueLevels();
    writeVersion();
  }
}
